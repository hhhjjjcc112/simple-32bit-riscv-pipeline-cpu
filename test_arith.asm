# 复杂计算测试程序（使用li伪指令）
# 执行一系列复杂计算，最终结果写入x1寄存器
# 预期结果: x1 = 0x12345678

.text
# 复杂计算序列生成 0x12345678
# 使用多个步骤和运算构建目标值，最终结果写入x1寄存器

.text
.global _start
_start:
    # 初始化小值
    li t0, 0x1111      # 初始值1
    li t1, 0x2222      # 初始值2
    li t2, 0x3333      # 初始值3
    li t3, 0x4444      # 初始值4
    
    # 第一步：构建基础值
    slli a0, t0, 4     # a0 = 0x11110 (0x1111 << 4)
    add a0, a0, t1     # a0 = 0x13332 (0x11110 + 0x2222)
    xor a0, a0, t2     # a0 = 0x10001 (0x13332 ^ 0x3333)
    
    # 第二步：扩展值
    slli a1, a0, 8     # a1 = 0x1000100 (0x10001 << 8)
    add a1, a1, a0     # a1 = 0x1000100 + 0x10001 = 0x1010101
    slli a1, a1, 4     # a1 = 0x10101010 (0x1010101 << 4)
    
    # 第三步：构建中间值
    li a2, 0x1234      # 加载部分目标值
    slli a2, a2, 8     # a2 = 0x123400 (0x1234 << 8)
    li a3, 0x5678      # 加载部分目标值
    
    # 第四步：复杂组合
    xor a4, a1, a2     # a4 = 0x10101010 ^ 0x123400 = 0x11241010
    and a5, a4, a3     # a5 = 0x11241010 & 0x5678 = 0x1000
    or a6, a5, a2      # a6 = 0x1000 | 0x123400 = 0x12341000
    
    # 第五步：调整到目标值
    sub a7, a6, a5     # a7 = 0x12341000 - 0x1000 = 0x12340000
    add s0, a7, a3     # s0 = 0x12340000 + 0x5678 = 0x12345678
    
    # 第六步：验证和修正
    li s1, 0x12345678  # 目标值
    xor s2, s0, s1     # 比较计算结果与目标值
    beqz s2, success   # 如果相等，跳转到成功
    
    # 如果不相等，尝试另一种方法
    li s3, 0x10000000  # 另一个基础值
    li s4, 0x02345678  # 部分目标值
    add s5, s3, s4     # s5 = 0x12345678
    mv s0, s5          # 更新结果
    
success:
    # 将最终结果存入x1
    mv x1, s0          # x1 = 0x12345678
    
    # 程序结束，无限循环
end:
    j end